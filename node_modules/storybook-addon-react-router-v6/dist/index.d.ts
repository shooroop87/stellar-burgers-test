import * as _storybook_preview_api_dist_addons from '@storybook/preview-api/dist/addons';
import * as React from 'react';
import React__default from 'react';

declare const withRouter: _storybook_preview_api_dist_addons.MakeDecoratorResult;

/**
 * Actions represent the type of change to a location value.
 */
declare enum Action {
    /**
     * A POP indicates a change to an arbitrary index in the history stack, such
     * as a back or forward navigation. It does not describe the direction of the
     * navigation, only that the current index changed.
     *
     * Note: This is the default action for newly created history objects.
     */
    Pop = "POP",
    /**
     * A PUSH indicates a new entry being added to the history stack, such as when
     * a link is clicked and a new page loads. When this happens, all subsequent
     * entries in the stack are lost.
     */
    Push = "PUSH",
    /**
     * A REPLACE indicates the entry at the current index in the history stack
     * being replaced by a new one.
     */
    Replace = "REPLACE"
}
/**
 * The pathname, search, and hash values of a URL.
 */
interface Path {
    /**
     * A URL pathname, beginning with a /.
     */
    pathname: string;
    /**
     * A URL search string, beginning with a ?.
     */
    search: string;
    /**
     * A URL fragment identifier, beginning with a #.
     */
    hash: string;
}
/**
 * An entry in a history stack. A location contains information about the
 * URL path, as well as possibly some arbitrary state and a key.
 */
interface Location extends Path {
    /**
     * A value of arbitrary data associated with this location.
     */
    state: any;
    /**
     * A unique string associated with this location. May be used to safely store
     * and retrieve data in some other storage API, like `localStorage`.
     *
     * Note: This value is always "default" on the initial location.
     */
    key: string;
}

/**
 * Map of routeId -> data returned from a loader/action/error
 */
interface RouteData {
    [routeId: string]: any;
}
declare enum ResultType$1 {
    data = "data",
    deferred = "deferred",
    redirect = "redirect",
    error = "error"
}
/**
 * Successful result from a loader or action
 */
interface SuccessResult$1 {
    type: ResultType$1.data;
    data: any;
    statusCode?: number;
    headers?: Headers;
}
/**
 * Successful defer() result from a loader or action
 */
interface DeferredResult$1 {
    type: ResultType$1.deferred;
    deferredData: DeferredData$1;
    statusCode?: number;
    headers?: Headers;
}
/**
 * Redirect result from a loader or action
 */
interface RedirectResult$1 {
    type: ResultType$1.redirect;
    status: number;
    location: string;
    revalidate: boolean;
}
/**
 * Unsuccessful result from a loader or action
 */
interface ErrorResult$1 {
    type: ResultType$1.error;
    error: any;
    headers?: Headers;
}
/**
 * Result from a loader or action - potentially successful or unsuccessful
 */
declare type DataResult$1 = SuccessResult$1 | DeferredResult$1 | RedirectResult$1 | ErrorResult$1;
declare type MutationFormMethod = "post" | "put" | "patch" | "delete";
declare type FormMethod$1 = "get" | MutationFormMethod;
declare type FormEncType$1 = "application/x-www-form-urlencoded" | "multipart/form-data";
/**
 * @private
 * Internal interface to pass around for action submissions, not intended for
 * external consumption
 */
interface Submission$1 {
    formMethod: FormMethod$1;
    formAction: string;
    formEncType: FormEncType$1;
    formData: FormData;
}
/**
 * @private
 * Arguments passed to route loader/action functions.  Same for now but we keep
 * this as a private implementation detail in case they diverge in the future.
 */
interface DataFunctionArgs$1 {
    request: Request;
    params: Params$1;
    context?: any;
}
/**
 * Arguments passed to loader functions
 */
interface LoaderFunctionArgs$1 extends DataFunctionArgs$1 {
}
/**
 * Arguments passed to action functions
 */
interface ActionFunctionArgs$1 extends DataFunctionArgs$1 {
}
/**
 * Route loader function signature
 */
interface LoaderFunction$1 {
    (args: LoaderFunctionArgs$1): Promise<Response> | Response | Promise<any> | any;
}
/**
 * Route action function signature
 */
interface ActionFunction$1 {
    (args: ActionFunctionArgs$1): Promise<Response> | Response | Promise<any> | any;
}
/**
 * Route shouldRevalidate function signature.  This runs after any submission
 * (navigation or fetcher), so we flatten the navigation/fetcher submission
 * onto the arguments.  It shouldn't matter whether it came from a navigation
 * or a fetcher, what really matters is the URLs and the formData since loaders
 * have to re-run based on the data models that were potentially mutated.
 */
interface ShouldRevalidateFunction$1 {
    (args: {
        currentUrl: URL;
        currentParams: AgnosticDataRouteMatch$1["params"];
        nextUrl: URL;
        nextParams: AgnosticDataRouteMatch$1["params"];
        formMethod?: Submission$1["formMethod"];
        formAction?: Submission$1["formAction"];
        formEncType?: Submission$1["formEncType"];
        formData?: Submission$1["formData"];
        actionResult?: DataResult$1;
        defaultShouldRevalidate: boolean;
    }): boolean;
}
/**
 * Base RouteObject with common props shared by all types of routes
 */
declare type AgnosticBaseRouteObject$1 = {
    caseSensitive?: boolean;
    path?: string;
    id?: string;
    loader?: LoaderFunction$1;
    action?: ActionFunction$1;
    hasErrorBoundary?: boolean;
    shouldRevalidate?: ShouldRevalidateFunction$1;
    handle?: any;
};
/**
 * Index routes must not have children
 */
declare type AgnosticIndexRouteObject$1 = AgnosticBaseRouteObject$1 & {
    children?: undefined;
    index: true;
};
/**
 * Non-index routes may have children, but cannot have index
 */
declare type AgnosticNonIndexRouteObject$1 = AgnosticBaseRouteObject$1 & {
    children?: AgnosticRouteObject$1[];
    index?: false;
};
/**
 * A route object represents a logical route, with (optionally) its child
 * routes organized in a tree-like structure.
 */
declare type AgnosticRouteObject$1 = AgnosticIndexRouteObject$1 | AgnosticNonIndexRouteObject$1;
declare type AgnosticDataIndexRouteObject$1 = AgnosticIndexRouteObject$1 & {
    id: string;
};
declare type AgnosticDataNonIndexRouteObject$1 = AgnosticNonIndexRouteObject$1 & {
    children?: AgnosticDataRouteObject$1[];
    id: string;
};
/**
 * A data route object, which is just a RouteObject with a required unique ID
 */
declare type AgnosticDataRouteObject$1 = AgnosticDataIndexRouteObject$1 | AgnosticDataNonIndexRouteObject$1;
/**
 * The parameters that were parsed from the URL path.
 */
declare type Params$1<Key extends string = string> = {
    readonly [key in Key]: string | undefined;
};
/**
 * A RouteMatch contains info about how a route matched a URL.
 */
interface AgnosticRouteMatch$1<ParamKey extends string = string, RouteObjectType extends AgnosticRouteObject$1 = AgnosticRouteObject$1> {
    /**
     * The names and values of dynamic parameters in the URL.
     */
    params: Params$1<ParamKey>;
    /**
     * The portion of the URL pathname that was matched.
     */
    pathname: string;
    /**
     * The portion of the URL pathname that was matched before child routes.
     */
    pathnameBase: string;
    /**
     * The route object that was used to match.
     */
    route: RouteObjectType;
}
interface AgnosticDataRouteMatch$1 extends AgnosticRouteMatch$1<string, AgnosticDataRouteObject$1> {
}
declare class DeferredData$1 {
    private pendingKeysSet;
    private controller;
    private abortPromise;
    private unlistenAbortSignal;
    private subscribers;
    data: Record<string, unknown>;
    init?: ResponseInit;
    deferredKeys: string[];
    constructor(data: Record<string, unknown>, responseInit?: ResponseInit);
    private trackPromise;
    private onSettle;
    private emit;
    subscribe(fn: (aborted: boolean, settledKey?: string) => void): () => boolean;
    cancel(): void;
    resolveData(signal: AbortSignal): Promise<boolean>;
    get done(): boolean;
    get unwrappedData(): {};
    get pendingKeys(): string[];
}

/**
 * State maintained internally by the router.  During a navigation, all states
 * reflect the the "old" location unless otherwise noted.
 */
interface RouterState {
    /**
     * The action of the most recent navigation
     */
    historyAction: Action;
    /**
     * The current location reflected by the router
     */
    location: Location;
    /**
     * The current set of route matches
     */
    matches: AgnosticDataRouteMatch$1[];
    /**
     * Tracks whether we've completed our initial data load
     */
    initialized: boolean;
    /**
     * Current scroll position we should start at for a new view
     *  - number -> scroll position to restore to
     *  - false -> do not restore scroll at all (used during submissions)
     *  - null -> don't have a saved position, scroll to hash or top of page
     */
    restoreScrollPosition: number | false | null;
    /**
     * Indicate whether this navigation should skip resetting the scroll position
     * if we are unable to restore the scroll position
     */
    preventScrollReset: boolean;
    /**
     * Tracks the state of the current navigation
     */
    navigation: Navigation;
    /**
     * Tracks any in-progress revalidations
     */
    revalidation: RevalidationState;
    /**
     * Data from the loaders for the current matches
     */
    loaderData: RouteData;
    /**
     * Data from the action for the current matches
     */
    actionData: RouteData | null;
    /**
     * Errors caught from loaders for the current matches
     */
    errors: RouteData | null;
    /**
     * Map of current fetchers
     */
    fetchers: Map<string, Fetcher>;
    /**
     * Map of current blockers
     */
    blockers: Map<string, Blocker>;
}
/**
 * Data that can be passed into hydrate a Router from SSR
 */
declare type HydrationState = Partial<Pick<RouterState, "loaderData" | "actionData" | "errors">>;
/**
 * Potential states for state.navigation
 */
declare type NavigationStates = {
    Idle: {
        state: "idle";
        location: undefined;
        formMethod: undefined;
        formAction: undefined;
        formEncType: undefined;
        formData: undefined;
    };
    Loading: {
        state: "loading";
        location: Location;
        formMethod: FormMethod$1 | undefined;
        formAction: string | undefined;
        formEncType: FormEncType$1 | undefined;
        formData: FormData | undefined;
    };
    Submitting: {
        state: "submitting";
        location: Location;
        formMethod: FormMethod$1;
        formAction: string;
        formEncType: FormEncType$1;
        formData: FormData;
    };
};
declare type Navigation = NavigationStates[keyof NavigationStates];
declare type RevalidationState = "idle" | "loading";
/**
 * Potential states for fetchers
 */
declare type FetcherStates<TData = any> = {
    Idle: {
        state: "idle";
        formMethod: undefined;
        formAction: undefined;
        formEncType: undefined;
        formData: undefined;
        data: TData | undefined;
        " _hasFetcherDoneAnything "?: boolean;
    };
    Loading: {
        state: "loading";
        formMethod: FormMethod$1 | undefined;
        formAction: string | undefined;
        formEncType: FormEncType$1 | undefined;
        formData: FormData | undefined;
        data: TData | undefined;
        " _hasFetcherDoneAnything "?: boolean;
    };
    Submitting: {
        state: "submitting";
        formMethod: FormMethod$1;
        formAction: string;
        formEncType: FormEncType$1;
        formData: FormData;
        data: TData | undefined;
        " _hasFetcherDoneAnything "?: boolean;
    };
};
declare type Fetcher<TData = any> = FetcherStates<TData>[keyof FetcherStates<TData>];
interface BlockerBlocked {
    state: "blocked";
    reset(): void;
    proceed(): void;
    location: Location;
}
interface BlockerUnblocked {
    state: "unblocked";
    reset: undefined;
    proceed: undefined;
    location: undefined;
}
interface BlockerProceeding {
    state: "proceeding";
    reset: undefined;
    proceed: undefined;
    location: Location;
}
declare type Blocker = BlockerUnblocked | BlockerBlocked | BlockerProceeding;

declare enum ResultType {
    data = "data",
    deferred = "deferred",
    redirect = "redirect",
    error = "error"
}
/**
 * Successful result from a loader or action
 */
interface SuccessResult {
    type: ResultType.data;
    data: any;
    statusCode?: number;
    headers?: Headers;
}
/**
 * Successful defer() result from a loader or action
 */
interface DeferredResult {
    type: ResultType.deferred;
    deferredData: DeferredData;
    statusCode?: number;
    headers?: Headers;
}
/**
 * Redirect result from a loader or action
 */
interface RedirectResult {
    type: ResultType.redirect;
    status: number;
    location: string;
    revalidate: boolean;
}
/**
 * Unsuccessful result from a loader or action
 */
interface ErrorResult {
    type: ResultType.error;
    error: any;
    headers?: Headers;
}
/**
 * Result from a loader or action - potentially successful or unsuccessful
 */
type DataResult = SuccessResult | DeferredResult | RedirectResult | ErrorResult;
type LowerCaseFormMethod = "get" | "post" | "put" | "patch" | "delete";
type UpperCaseFormMethod = Uppercase<LowerCaseFormMethod>;
/**
 * Active navigation/fetcher form methods are exposed in lowercase on the
 * RouterState
 */
type FormMethod = LowerCaseFormMethod;
/**
 * In v7, active navigation/fetcher form methods are exposed in uppercase on the
 * RouterState.  This is to align with the normalization done via fetch().
 */
type V7_FormMethod = UpperCaseFormMethod;
type FormEncType = "application/x-www-form-urlencoded" | "multipart/form-data" | "application/json" | "text/plain";
type JsonObject = {
    [Key in string]: JsonValue;
} & {
    [Key in string]?: JsonValue | undefined;
};
type JsonArray = JsonValue[] | readonly JsonValue[];
type JsonPrimitive = string | number | boolean | null;
type JsonValue = JsonPrimitive | JsonObject | JsonArray;
/**
 * @private
 * Internal interface to pass around for action submissions, not intended for
 * external consumption
 */
type Submission = {
    formMethod: FormMethod | V7_FormMethod;
    formAction: string;
    formEncType: FormEncType;
    formData: FormData;
    json: undefined;
    text: undefined;
} | {
    formMethod: FormMethod | V7_FormMethod;
    formAction: string;
    formEncType: FormEncType;
    formData: undefined;
    json: JsonValue;
    text: undefined;
} | {
    formMethod: FormMethod | V7_FormMethod;
    formAction: string;
    formEncType: FormEncType;
    formData: undefined;
    json: undefined;
    text: string;
};
/**
 * @private
 * Arguments passed to route loader/action functions.  Same for now but we keep
 * this as a private implementation detail in case they diverge in the future.
 */
interface DataFunctionArgs {
    request: Request;
    params: Params;
    context?: any;
}
/**
 * Arguments passed to loader functions
 */
interface LoaderFunctionArgs extends DataFunctionArgs {
}
/**
 * Arguments passed to action functions
 */
interface ActionFunctionArgs extends DataFunctionArgs {
}
/**
 * Loaders and actions can return anything except `undefined` (`null` is a
 * valid return value if there is no data to return).  Responses are preferred
 * and will ease any future migration to Remix
 */
type DataFunctionValue = Response | NonNullable<unknown> | null;
/**
 * Route loader function signature
 */
interface LoaderFunction {
    (args: LoaderFunctionArgs): Promise<DataFunctionValue> | DataFunctionValue;
}
/**
 * Route action function signature
 */
interface ActionFunction {
    (args: ActionFunctionArgs): Promise<DataFunctionValue> | DataFunctionValue;
}
/**
 * Route shouldRevalidate function signature.  This runs after any submission
 * (navigation or fetcher), so we flatten the navigation/fetcher submission
 * onto the arguments.  It shouldn't matter whether it came from a navigation
 * or a fetcher, what really matters is the URLs and the formData since loaders
 * have to re-run based on the data models that were potentially mutated.
 */
interface ShouldRevalidateFunction {
    (args: {
        currentUrl: URL;
        currentParams: AgnosticDataRouteMatch["params"];
        nextUrl: URL;
        nextParams: AgnosticDataRouteMatch["params"];
        formMethod?: Submission["formMethod"];
        formAction?: Submission["formAction"];
        formEncType?: Submission["formEncType"];
        text?: Submission["text"];
        formData?: Submission["formData"];
        json?: Submission["json"];
        actionResult?: DataResult;
        defaultShouldRevalidate: boolean;
    }): boolean;
}
/**
 * Keys we cannot change from within a lazy() function. We spread all other keys
 * onto the route. Either they're meaningful to the router, or they'll get
 * ignored.
 */
type ImmutableRouteKey = "lazy" | "caseSensitive" | "path" | "id" | "index" | "children";
type RequireOne<T, Key = keyof T> = Exclude<{
    [K in keyof T]: K extends Key ? Omit<T, K> & Required<Pick<T, K>> : never;
}[keyof T], undefined>;
/**
 * lazy() function to load a route definition, which can add non-matching
 * related properties to a route
 */
interface LazyRouteFunction<R extends AgnosticRouteObject> {
    (): Promise<RequireOne<Omit<R, ImmutableRouteKey>>>;
}
/**
 * Base RouteObject with common props shared by all types of routes
 */
type AgnosticBaseRouteObject = {
    caseSensitive?: boolean;
    path?: string;
    id?: string;
    loader?: LoaderFunction;
    action?: ActionFunction;
    hasErrorBoundary?: boolean;
    shouldRevalidate?: ShouldRevalidateFunction;
    handle?: any;
    lazy?: LazyRouteFunction<AgnosticBaseRouteObject>;
};
/**
 * Index routes must not have children
 */
type AgnosticIndexRouteObject = AgnosticBaseRouteObject & {
    children?: undefined;
    index: true;
};
/**
 * Non-index routes may have children, but cannot have index
 */
type AgnosticNonIndexRouteObject = AgnosticBaseRouteObject & {
    children?: AgnosticRouteObject[];
    index?: false;
};
/**
 * A route object represents a logical route, with (optionally) its child
 * routes organized in a tree-like structure.
 */
type AgnosticRouteObject = AgnosticIndexRouteObject | AgnosticNonIndexRouteObject;
type AgnosticDataIndexRouteObject = AgnosticIndexRouteObject & {
    id: string;
};
type AgnosticDataNonIndexRouteObject = AgnosticNonIndexRouteObject & {
    children?: AgnosticDataRouteObject[];
    id: string;
};
/**
 * A data route object, which is just a RouteObject with a required unique ID
 */
type AgnosticDataRouteObject = AgnosticDataIndexRouteObject | AgnosticDataNonIndexRouteObject;
/**
 * The parameters that were parsed from the URL path.
 */
type Params<Key extends string = string> = {
    readonly [key in Key]: string | undefined;
};
/**
 * A RouteMatch contains info about how a route matched a URL.
 */
interface AgnosticRouteMatch<ParamKey extends string = string, RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject> {
    /**
     * The names and values of dynamic parameters in the URL.
     */
    params: Params<ParamKey>;
    /**
     * The portion of the URL pathname that was matched.
     */
    pathname: string;
    /**
     * The portion of the URL pathname that was matched before child routes.
     */
    pathnameBase: string;
    /**
     * The route object that was used to match.
     */
    route: RouteObjectType;
}
interface AgnosticDataRouteMatch extends AgnosticRouteMatch<string, AgnosticDataRouteObject> {
}
declare class DeferredData {
    private pendingKeysSet;
    private controller;
    private abortPromise;
    private unlistenAbortSignal;
    private subscribers;
    data: Record<string, unknown>;
    init?: ResponseInit;
    deferredKeys: string[];
    constructor(data: Record<string, unknown>, responseInit?: ResponseInit);
    private trackPromise;
    private onSettle;
    private emit;
    subscribe(fn: (aborted: boolean, settledKey?: string) => void): () => boolean;
    cancel(): void;
    resolveData(signal: AbortSignal): Promise<boolean>;
    get done(): boolean;
    get unwrappedData(): {};
    get pendingKeys(): string[];
}

interface IndexRouteObject {
    caseSensitive?: AgnosticIndexRouteObject["caseSensitive"];
    path?: AgnosticIndexRouteObject["path"];
    id?: AgnosticIndexRouteObject["id"];
    loader?: AgnosticIndexRouteObject["loader"];
    action?: AgnosticIndexRouteObject["action"];
    hasErrorBoundary?: AgnosticIndexRouteObject["hasErrorBoundary"];
    shouldRevalidate?: AgnosticIndexRouteObject["shouldRevalidate"];
    handle?: AgnosticIndexRouteObject["handle"];
    index: true;
    children?: undefined;
    element?: React.ReactNode | null;
    errorElement?: React.ReactNode | null;
    Component?: React.ComponentType | null;
    ErrorBoundary?: React.ComponentType | null;
    lazy?: LazyRouteFunction<RouteObject>;
}
interface NonIndexRouteObject {
    caseSensitive?: AgnosticNonIndexRouteObject["caseSensitive"];
    path?: AgnosticNonIndexRouteObject["path"];
    id?: AgnosticNonIndexRouteObject["id"];
    loader?: AgnosticNonIndexRouteObject["loader"];
    action?: AgnosticNonIndexRouteObject["action"];
    hasErrorBoundary?: AgnosticNonIndexRouteObject["hasErrorBoundary"];
    shouldRevalidate?: AgnosticNonIndexRouteObject["shouldRevalidate"];
    handle?: AgnosticNonIndexRouteObject["handle"];
    index?: false;
    children?: RouteObject[];
    element?: React.ReactNode | null;
    errorElement?: React.ReactNode | null;
    Component?: React.ComponentType | null;
    ErrorBoundary?: React.ComponentType | null;
    lazy?: LazyRouteFunction<RouteObject>;
}
type RouteObject = IndexRouteObject | NonIndexRouteObject;

/**
 * SetDifference (same as Exclude)
 * @desc Set difference of given union types `A` and `B`
 * @example
 *   // Expect: "1"
 *   SetDifference<'1' | '2' | '3', '2' | '3' | '4'>;
 *
 *   // Expect: string | number
 *   SetDifference<string | number | (() => void), Function>;
 */
declare type SetDifference<A, B> = A extends B ? never : A;
/**
 * Intersection
 * @desc From `T` pick properties that exist in `U`
 * @example
 *   type Props = { name: string; age: number; visible: boolean };
 *   type DefaultProps = { age: number };
 *
 *   // Expect: { age: number; }
 *   type DuplicateProps = Intersection<Props, DefaultProps>;
 */
declare type Intersection<T extends object, U extends object> = Pick<T, Extract<keyof T, keyof U> & Extract<keyof U, keyof T>>;
/**
 * Diff
 * @desc From `T` remove properties that exist in `U`
 * @example
 *   type Props = { name: string; age: number; visible: boolean };
 *   type DefaultProps = { age: number };
 *
 *   // Expect: { name: string; visible: boolean; }
 *   type DiffProps = Diff<Props, DefaultProps>;
 */
declare type Diff<T extends object, U extends object> = Pick<T, SetDifference<keyof T, keyof U>>;
/**
 * Overwrite
 * @desc From `U` overwrite properties to `T`
 * @example
 *   type Props = { name: string; age: number; visible: boolean };
 *   type NewProps = { age: string; other: string };
 *
 *   // Expect: { name: string; age: string; visible: boolean; }
 *   type ReplacedProps = Overwrite<Props, NewProps>;
 */
declare type Overwrite<T extends object, U extends object, I = Diff<T, U> & Intersection<U, T>> = Pick<I, keyof I>;

type Merge<T, Deep = false> = {
    [K in keyof T]: Deep extends true ? (T extends object ? Merge<T[K], true> : T[K]) : T[K];
} & {};

type RouterParameters = {
    hydrationData?: HydrationState;
    routing?: string | RouterRoute | [RouterRoute, ...RouterRoute[]];
};
type LocationParameters<PathParams extends Record<string, string | number> = Record<string, string | number>> = {
    path?: string | ((inferredPath: string, pathParams: PathParams) => string | undefined);
    pathParams?: PathParams;
    searchParams?: ConstructorParameters<typeof URLSearchParams>[0];
    hash?: string;
    state?: unknown;
};
type NavigationHistoryEntry = LocationParameters & {
    isInitialLocation?: boolean;
};
type RouterRoute = Overwrite<RouteObject, {
    children?: RouterRoute[];
}> & StoryRouteIdentifier;
type RouteDefinition = React__default.ReactElement | RouteDefinitionObject;
type NonIndexRouteDefinition = React__default.ReactElement | NonIndexRouteDefinitionObject;
type RouteDefinitionObject = Merge<Omit<RouteObject, 'children'> & StoryRouteIdentifier>;
type NonIndexRouteDefinitionObject = RouteDefinitionObject & {
    index?: false;
};
type StoryRouteIdentifier = {
    useStoryElement?: boolean;
};
type RoutingHelper = (...args: never[]) => [RouterRoute, ...RouterRoute[]];

type ReactRouterAddonStoryParameters = (RouterParameters & {
    location?: LocationParameters;
    navigationHistory?: never;
}) | (RouterParameters & {
    location?: never;
    navigationHistory: [NavigationHistoryEntry, ...NavigationHistoryEntry[]];
});

declare function reactRouterParameters(params: ReactRouterAddonStoryParameters): ReactRouterAddonStoryParameters;

type StoryRouteDefinition = string | Omit<NonIndexRouteDefinitionObject, 'element'>;

/**
 * Render the story with a single outlet
 * @see withOutlets
 * @see withNestedOutlets
 */
declare function reactRouterOutlet(outlet: RouteDefinition): [RouterRoute];
declare function reactRouterOutlet(story: StoryRouteDefinition, outlet: RouteDefinition): [RouterRoute];

/**
 * Render the story with multiple possible outlets.
 * Use this function when your story component can navigate and you want a different outlet depending on the path.
 * @see withOutlet
 * @see withNestedOutlets
 */
declare function reactRouterOutlets(outlets: RouteDefinitionObject[]): [RouterRoute];
declare function reactRouterOutlets(story: string | Omit<NonIndexRouteDefinitionObject, 'element'>, outlets: RouteDefinitionObject[]): [RouterRoute];

/**
 * Render the story with multiple outlets nested one into the previous.
 * Use this function when your story component renders an outlet that itself can have outlet and so forth.
 * Outlets are nested in a visual/JSX order : the first element of the array will be the root, the last will be
 * the direct parent of the story
 * @see withOutlet
 * @see withOutlets
 */
declare function reactRouterNestedOutlets(outlets: [...RouteDefinition[], NonIndexRouteDefinition]): [RouterRoute];
declare function reactRouterNestedOutlets(story: StoryRouteDefinition, outlets: [...RouteDefinition[], NonIndexRouteDefinition]): [RouterRoute];

/**
 * Render the story as the outlet of an ancestor.
 * You can specify multiple ancestors to create a deep nesting.
 * Outlets are nested in a visual/JSX order : the first element of the array will be the root, the last will be
 * the direct parent of the story
 */
declare function reactRouterNestedAncestors(ancestors: NonIndexRouteDefinition | NonIndexRouteDefinition[]): [RouterRoute];
declare function reactRouterNestedAncestors(story: Omit<RouteDefinitionObject, 'element'>, ancestors: NonIndexRouteDefinition | NonIndexRouteDefinition[]): [RouterRoute];

declare function castRouterRoute(definition: RouteDefinition): RouterRoute;

export { NonIndexRouteDefinition, NonIndexRouteDefinitionObject, ReactRouterAddonStoryParameters, RouteDefinition, RouteDefinitionObject, RouterRoute, RoutingHelper, castRouterRoute, reactRouterNestedAncestors, reactRouterNestedOutlets, reactRouterOutlet, reactRouterOutlets, reactRouterParameters, withRouter };
